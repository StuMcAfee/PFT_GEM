"""
Displacement Field Operations and Utilities

This module provides the DisplacementField class for handling, manipulating,
and analyzing displacement vector fields generated by the geometric expansion
model or loaded from external sources.
"""

import numpy as np
from typing import Optional, Tuple, Union, List
from dataclasses import dataclass
from scipy import ndimage
from scipy.interpolate import RegularGridInterpolator


@dataclass
class FieldMetadata:
    """Metadata for displacement fields.

    Attributes:
        shape: Grid dimensions (nx, ny, nz)
        voxel_size: Voxel dimensions in mm
        origin: Origin coordinates in mm
        affine: 4x4 affine transformation matrix
        units: Units of displacement ('mm' or 'voxels')
    """
    shape: Tuple[int, int, int]
    voxel_size: Tuple[float, float, float] = (1.0, 1.0, 1.0)
    origin: Tuple[float, float, float] = (0.0, 0.0, 0.0)
    affine: Optional[np.ndarray] = None
    units: str = "mm"


class DisplacementField:
    """
    Class for handling displacement vector fields.

    This class provides methods for loading, manipulating, composing,
    and analyzing displacement fields. It supports common operations
    needed for tumor displacement modeling and image registration.

    Parameters
    ----------
    data : np.ndarray
        4D array of shape (nx, ny, nz, 3) containing displacement vectors
    metadata : FieldMetadata, optional
        Metadata describing the field geometry

    Examples
    --------
    >>> field = DisplacementField(displacement_array)
    >>> magnitude = field.magnitude()
    >>> warped_points = field.apply_to_points(points)
    """

    def __init__(
        self,
        data: np.ndarray,
        metadata: Optional[FieldMetadata] = None
    ):
        if data.ndim != 4 or data.shape[-1] != 3:
            raise ValueError(
                f"Expected 4D array with shape (nx, ny, nz, 3), got {data.shape}"
            )

        self.data = data.astype(np.float64)
        self.metadata = metadata or FieldMetadata(shape=data.shape[:3])

    @property
    def shape(self) -> Tuple[int, int, int]:
        """Return spatial dimensions of the field."""
        return self.data.shape[:3]

    @property
    def voxel_size(self) -> Tuple[float, float, float]:
        """Return voxel size in mm."""
        return self.metadata.voxel_size

    def magnitude(self) -> np.ndarray:
        """
        Compute displacement magnitude at each voxel.

        Returns
        -------
        magnitude : np.ndarray
            3D array of displacement magnitudes in mm
        """
        return np.linalg.norm(self.data, axis=-1)

    def max_displacement(self) -> float:
        """Return maximum displacement magnitude."""
        return float(np.max(self.magnitude()))

    def mean_displacement(self, mask: Optional[np.ndarray] = None) -> float:
        """
        Compute mean displacement magnitude.

        Parameters
        ----------
        mask : np.ndarray, optional
            Binary mask for region of interest

        Returns
        -------
        mean : float
            Mean displacement magnitude in mm
        """
        mag = self.magnitude()
        if mask is not None:
            return float(np.mean(mag[mask > 0]))
        return float(np.mean(mag))

    def divergence(self) -> np.ndarray:
        """
        Compute divergence of the displacement field.

        The divergence indicates local volume change rate:
        - Positive: expansion
        - Negative: compression
        - Zero: incompressible flow

        Returns
        -------
        div : np.ndarray
            3D array of divergence values
        """
        div = np.zeros(self.shape)
        for i in range(3):
            div += np.gradient(
                self.data[..., i],
                self.metadata.voxel_size[i],
                axis=i
            )
        return div

    def curl(self) -> np.ndarray:
        """
        Compute curl (rotation) of the displacement field.

        Returns
        -------
        curl : np.ndarray
            4D array of curl vectors
        """
        curl = np.zeros_like(self.data)

        # du_z/dy - du_y/dz
        curl[..., 0] = (
            np.gradient(self.data[..., 2], self.metadata.voxel_size[1], axis=1) -
            np.gradient(self.data[..., 1], self.metadata.voxel_size[2], axis=2)
        )

        # du_x/dz - du_z/dx
        curl[..., 1] = (
            np.gradient(self.data[..., 0], self.metadata.voxel_size[2], axis=2) -
            np.gradient(self.data[..., 2], self.metadata.voxel_size[0], axis=0)
        )

        # du_y/dx - du_x/dy
        curl[..., 2] = (
            np.gradient(self.data[..., 1], self.metadata.voxel_size[0], axis=0) -
            np.gradient(self.data[..., 0], self.metadata.voxel_size[1], axis=1)
        )

        return curl

    def jacobian_determinant(self) -> np.ndarray:
        """
        Compute Jacobian determinant of the deformation.

        The deformation is x' = x + u(x), so the Jacobian is I + grad(u).

        Returns
        -------
        det_J : np.ndarray
            3D array of Jacobian determinant values
        """
        # Build deformation gradient tensor F = I + grad(u)
        F = np.zeros((*self.shape, 3, 3))

        for i in range(3):
            F[..., i, i] = 1.0  # Identity
            for j in range(3):
                F[..., i, j] += np.gradient(
                    self.data[..., i],
                    self.metadata.voxel_size[j],
                    axis=j
                )

        return np.linalg.det(F)

    def strain_tensor(self) -> np.ndarray:
        """
        Compute Green-Lagrange strain tensor.

        E = 0.5 * (F^T F - I) where F is the deformation gradient.

        Returns
        -------
        strain : np.ndarray
            5D array of shape (nx, ny, nz, 3, 3) containing strain tensors
        """
        # Build deformation gradient tensor
        F = np.zeros((*self.shape, 3, 3))

        for i in range(3):
            F[..., i, i] = 1.0
            for j in range(3):
                F[..., i, j] += np.gradient(
                    self.data[..., i],
                    self.metadata.voxel_size[j],
                    axis=j
                )

        # E = 0.5 * (F^T F - I)
        FtF = np.einsum('...ki,...kj->...ij', F, F)
        I = np.eye(3)
        strain = 0.5 * (FtF - I)

        return strain

    def von_mises_strain(self) -> np.ndarray:
        """
        Compute von Mises equivalent strain.

        This scalar measure of strain intensity is useful for
        identifying regions of high deformation.

        Returns
        -------
        vm_strain : np.ndarray
            3D array of von Mises strain values
        """
        E = self.strain_tensor()

        # Deviatoric strain
        trace_E = np.trace(E, axis1=-2, axis2=-1)
        E_dev = E - (trace_E / 3.0)[..., np.newaxis, np.newaxis] * np.eye(3)

        # von Mises strain
        vm = np.sqrt(2.0/3.0 * np.einsum('...ij,...ij', E_dev, E_dev))

        return vm

    def smooth(self, sigma: float = 1.0) -> "DisplacementField":
        """
        Apply Gaussian smoothing to the displacement field.

        Parameters
        ----------
        sigma : float
            Smoothing sigma in mm

        Returns
        -------
        smoothed : DisplacementField
            New smoothed displacement field
        """
        sigma_voxels = [sigma / vs for vs in self.metadata.voxel_size]

        smoothed_data = np.zeros_like(self.data)
        for i in range(3):
            smoothed_data[..., i] = ndimage.gaussian_filter(
                self.data[..., i], sigma=sigma_voxels
            )

        return DisplacementField(smoothed_data, self.metadata)

    def resample(
        self,
        new_shape: Tuple[int, int, int],
        new_voxel_size: Optional[Tuple[float, float, float]] = None
    ) -> "DisplacementField":
        """
        Resample the displacement field to a new grid.

        Parameters
        ----------
        new_shape : tuple
            New grid dimensions (nx, ny, nz)
        new_voxel_size : tuple, optional
            New voxel size in mm

        Returns
        -------
        resampled : DisplacementField
            Resampled displacement field
        """
        if new_voxel_size is None:
            # Compute voxel size to maintain physical extent
            new_voxel_size = tuple(
                self.metadata.voxel_size[i] * self.shape[i] / new_shape[i]
                for i in range(3)
            )

        # Create coordinate grids
        old_coords = [
            np.arange(s) * vs + self.metadata.origin[i]
            for i, (s, vs) in enumerate(zip(self.shape, self.metadata.voxel_size))
        ]

        new_coords = [
            np.arange(s) * vs + self.metadata.origin[i]
            for i, (s, vs) in enumerate(zip(new_shape, new_voxel_size))
        ]

        # Interpolate each component
        resampled_data = np.zeros((*new_shape, 3))
        for i in range(3):
            interp = RegularGridInterpolator(
                old_coords, self.data[..., i],
                method='linear', bounds_error=False, fill_value=0
            )

            # Create meshgrid for new coordinates
            new_grid = np.stack(
                np.meshgrid(*new_coords, indexing='ij'), axis=-1
            )
            resampled_data[..., i] = interp(new_grid)

        new_metadata = FieldMetadata(
            shape=new_shape,
            voxel_size=new_voxel_size,
            origin=self.metadata.origin,
            affine=self.metadata.affine,
            units=self.metadata.units
        )

        return DisplacementField(resampled_data, new_metadata)

    def apply_to_points(self, points: np.ndarray) -> np.ndarray:
        """
        Apply displacement to a set of points.

        Parameters
        ----------
        points : np.ndarray
            Nx3 array of point coordinates in mm

        Returns
        -------
        displaced_points : np.ndarray
            Nx3 array of displaced point coordinates
        """
        if points.ndim == 1:
            points = points.reshape(1, -1)

        # Create interpolators for each component
        coords = [
            np.arange(s) * vs + self.metadata.origin[i]
            for i, (s, vs) in enumerate(zip(self.shape, self.metadata.voxel_size))
        ]

        displaced = points.copy()
        for i in range(3):
            interp = RegularGridInterpolator(
                coords, self.data[..., i],
                method='linear', bounds_error=False, fill_value=0
            )
            displaced[:, i] += interp(points)

        return displaced

    def apply_to_image(
        self,
        image: np.ndarray,
        order: int = 1
    ) -> np.ndarray:
        """
        Apply displacement field to warp an image.

        Parameters
        ----------
        image : np.ndarray
            3D image array to warp
        order : int
            Interpolation order (0=nearest, 1=linear, 3=cubic)

        Returns
        -------
        warped : np.ndarray
            Warped image
        """
        if image.shape != self.shape:
            raise ValueError(
                f"Image shape {image.shape} does not match field shape {self.shape}"
            )

        # Create coordinate grids
        coords = np.indices(self.shape).astype(np.float64)

        # Add displacement (convert from mm to voxels)
        for i in range(3):
            coords[i] += self.data[..., i] / self.metadata.voxel_size[i]

        # Warp image using map_coordinates
        warped = ndimage.map_coordinates(
            image, coords, order=order, mode='constant', cval=0
        )

        return warped

    def compose(self, other: "DisplacementField") -> "DisplacementField":
        """
        Compose this displacement field with another.

        The result represents applying self first, then other.

        Parameters
        ----------
        other : DisplacementField
            Second displacement field to compose with

        Returns
        -------
        composed : DisplacementField
            Composed displacement field
        """
        # Warp 'other' by 'self', then add
        warped_other = np.zeros_like(self.data)

        coords = np.indices(self.shape).astype(np.float64)
        for i in range(3):
            coords[i] += self.data[..., i] / self.metadata.voxel_size[i]

        for i in range(3):
            warped_other[..., i] = ndimage.map_coordinates(
                other.data[..., i], coords, order=1, mode='constant', cval=0
            )

        composed_data = self.data + warped_other

        return DisplacementField(composed_data, self.metadata)

    def invert(self, iterations: int = 10, tolerance: float = 1e-4) -> "DisplacementField":
        """
        Compute the inverse displacement field.

        Uses iterative fixed-point inversion: u_inv = -u(x + u_inv)

        Parameters
        ----------
        iterations : int
            Number of iterations for inversion
        tolerance : float
            Convergence tolerance

        Returns
        -------
        inverse : DisplacementField
            Inverse displacement field
        """
        inverse_data = -self.data.copy()

        coords = np.indices(self.shape).astype(np.float64)

        for _ in range(iterations):
            # Warp self by current inverse estimate
            sample_coords = coords.copy()
            for i in range(3):
                sample_coords[i] += inverse_data[..., i] / self.metadata.voxel_size[i]

            warped = np.zeros_like(self.data)
            for i in range(3):
                warped[..., i] = ndimage.map_coordinates(
                    self.data[..., i], sample_coords, order=1, mode='constant', cval=0
                )

            new_inverse = -warped

            # Check convergence
            diff = np.max(np.abs(new_inverse - inverse_data))
            inverse_data = new_inverse

            if diff < tolerance:
                break

        return DisplacementField(inverse_data, self.metadata)

    def mask_region(
        self,
        mask: np.ndarray,
        value: float = 0.0
    ) -> "DisplacementField":
        """
        Set displacement to a constant value within a mask.

        Parameters
        ----------
        mask : np.ndarray
            Binary mask defining region
        value : float
            Value to set within mask

        Returns
        -------
        masked : DisplacementField
            New displacement field with masked region
        """
        masked_data = self.data.copy()
        masked_data[mask > 0] = value
        return DisplacementField(masked_data, self.metadata)

    def crop(
        self,
        start: Tuple[int, int, int],
        end: Tuple[int, int, int]
    ) -> "DisplacementField":
        """
        Crop the displacement field to a subregion.

        Parameters
        ----------
        start : tuple
            Starting indices (x, y, z)
        end : tuple
            Ending indices (x, y, z)

        Returns
        -------
        cropped : DisplacementField
            Cropped displacement field
        """
        cropped_data = self.data[
            start[0]:end[0],
            start[1]:end[1],
            start[2]:end[2],
            :
        ]

        new_origin = tuple(
            self.metadata.origin[i] + start[i] * self.metadata.voxel_size[i]
            for i in range(3)
        )

        new_metadata = FieldMetadata(
            shape=cropped_data.shape[:3],
            voxel_size=self.metadata.voxel_size,
            origin=new_origin,
            affine=None,  # Affine needs recomputation
            units=self.metadata.units
        )

        return DisplacementField(cropped_data, new_metadata)

    def statistics(self, mask: Optional[np.ndarray] = None) -> dict:
        """
        Compute summary statistics of the displacement field.

        Parameters
        ----------
        mask : np.ndarray, optional
            Binary mask for region of interest

        Returns
        -------
        stats : dict
            Dictionary of statistics
        """
        mag = self.magnitude()
        div = self.divergence()
        det_j = self.jacobian_determinant()

        if mask is not None:
            mag = mag[mask > 0]
            div = div[mask > 0]
            det_j = det_j[mask > 0]

        return {
            "magnitude": {
                "min": float(np.min(mag)),
                "max": float(np.max(mag)),
                "mean": float(np.mean(mag)),
                "std": float(np.std(mag)),
                "median": float(np.median(mag)),
            },
            "divergence": {
                "min": float(np.min(div)),
                "max": float(np.max(div)),
                "mean": float(np.mean(div)),
            },
            "jacobian": {
                "min": float(np.min(det_j)),
                "max": float(np.max(det_j)),
                "mean": float(np.mean(det_j)),
                "negative_fraction": float(np.mean(det_j < 0)),
            },
        }

    def __add__(self, other: "DisplacementField") -> "DisplacementField":
        """Add two displacement fields."""
        if self.shape != other.shape:
            raise ValueError("Displacement fields must have same shape")
        return DisplacementField(self.data + other.data, self.metadata)

    def __sub__(self, other: "DisplacementField") -> "DisplacementField":
        """Subtract two displacement fields."""
        if self.shape != other.shape:
            raise ValueError("Displacement fields must have same shape")
        return DisplacementField(self.data - other.data, self.metadata)

    def __mul__(self, scalar: float) -> "DisplacementField":
        """Scale displacement field."""
        return DisplacementField(self.data * scalar, self.metadata)

    def __rmul__(self, scalar: float) -> "DisplacementField":
        """Scale displacement field."""
        return self.__mul__(scalar)
